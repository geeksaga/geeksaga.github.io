<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux on Try to write anyway</title>
    <link>https://geeksaga.com/tags/linux/</link>
    <description>Recent content in linux on Try to write anyway</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://geeksaga.com/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>curl command</title>
      <link>https://geeksaga.com/2023/08/curl-command/</link>
      <pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2023/08/curl-command/</guid>
      <description>linux의 curl 명령어(CLI)는 URLs을 통해 데이터를 전송하는 명령어이다.
기본 사용법 $&amp;gt; curl https://geeksaga.com &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en-us&amp;#34;&amp;gt; ... &amp;lt;/html&amp;gt; help stow $&amp;gt; curl --help 10:49:17 Usage: curl [options...] &amp;lt;url&amp;gt; -d, --data &amp;lt;data&amp;gt; HTTP POST data -f, --fail Fail fast with no output on HTTP errors -h, --help &amp;lt;category&amp;gt; Get help for commands -i, --include Include protocol response headers in the output -o, --output &amp;lt;file&amp;gt; Write to file instead of stdout -O, --remote-name Write output to a file named as the remote file -s, --silent Silent mode -T, --upload-file &amp;lt;file&amp;gt; Transfer local FILE to destination -u, --user &amp;lt;user:password&amp;gt; Server user and password -A, --user-agent &amp;lt;name&amp;gt; Send User-Agent &amp;lt;name&amp;gt; to server -v, --verbose Make the operation more talkative -V, --version Show version number and quit This is not the full help, this menu is stripped into categories.</description>
    </item>
    
    <item>
      <title>stow command</title>
      <link>https://geeksaga.com/2023/01/stow-command/</link>
      <pubDate>Thu, 26 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2023/01/stow-command/</guid>
      <description>linux의 stow 명령어는 symbolic links를 관리해 주는 명령어이다.
dotfiles을 관리에 자주 사용되고, 소프트웨어 패키지 설치 관리자 역할을 하기도 한다.
stow를 이용하면 &amp;lsquo;/usr/local/stow/&amp;rsquo; 하위에 사용자가 컴파일 해서 사용하는 프로그램들을 만들어서 사용할 수 있게 된다.
요즘은 패키지 관리자들이 너무 잘 되어 있어서 굳이 패키지 관리 용도로 사용하는 모습은 잘 보이지 않는다.
기본 동작은 stow dir에서 지정된 이름의 디렉터리에 있는 파일을 현재 디렉터리 바로 위의 디렉터리에 링크한다.
stow를 사용할 때 주의 점은 디렉터리 구조가 목적에 맞게 미리 구성되어 있어야 한다.</description>
    </item>
    
    <item>
      <title>pmap command</title>
      <link>https://geeksaga.com/2022/04/pmap-command/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2022/04/pmap-command/</guid>
      <description>linux의 pmap 명령어를 통해 프로세스의 메모리 맵을 볼 수 있습니다.
기본 사용법 $&amp;gt; pmap -x 3273049 3273049: /opt/java/bin/java -Djava.util.logging.config.file=/opt/apache-tomcat-8.5.24/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -XX:+UseZGC -XX:ConcGCThreads=4 -XX:NativeMemoryTracking=detail Address Kbytes RSS Dirty Mode Mapping 0000000800000000 11932 11868 3728 rw--- classes_nocoops.jsa 0000000800ba7000 356 0 0 ----- [ anon ] 0000000800c00000 128 128 128 rw--- [ anon ] 0000000800c20000 128 128 128 rw--- [ anon ] ... 응용 프로세스 이름을 통해서 메모리 맵 확인하려면 grep 명령어와 awk 명령어를 사용합니다.</description>
    </item>
    
    <item>
      <title>dd command</title>
      <link>https://geeksaga.com/2020/09/dd-command/</link>
      <pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/09/dd-command/</guid>
      <description>linux의 dd 명령어를 통해 파일을 변환하거나 복사 할 수 있습니다.
기본 사용법 $&amp;gt; dd [OPERAND]... 응용 부팅 가능한 USB 만들기 $&amp;gt; sudo dd bs=4M if=archlinux-2020.09.01-x86_64.iso of=/dev/sdb status=progress oflag=sync 708837376 bytes (709 MB, 676 MiB) copied, 101.529 s, 7.0 MB/s 169+1 records in 169+1 records out 711983104 bytes (712 MB, 679 MiB) copied, 101.957 s, 7.0 MB/s TLDR $&amp;gt; tldr dd dd Convert and copy a file. - Make a bootable usb drive from an isohybrid file (such like archlinux-xxx.</description>
    </item>
    
    <item>
      <title>dmidecode command</title>
      <link>https://geeksaga.com/2020/09/dmidecode-command/</link>
      <pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/09/dmidecode-command/</guid>
      <description>linux의 dmidecode 명령어를 통해 DMI(SMBIOS) 정보를 출력해 줍니다.
기본 사용법 dmidecode 명령을 사용하려면 root 권한이 있어야 합니다.
$&amp;gt; sudo dmidecode | more # dmidecode 3.0 Getting SMBIOS data from sysfs. SMBIOS 2.7 present. 76 structures occupying 3048 bytes. Table at 0x000EB530. ... 응용 $&amp;gt; sudo dmidecode -t 0 # dmidecode 3.0 Getting SMBIOS data from sysfs. SMBIOS 2.7 present. Handle 0x0000, DMI type 0, 24 bytes BIOS Information Vendor: American Megatrends Inc.</description>
    </item>
    
    <item>
      <title>lsblk command</title>
      <link>https://geeksaga.com/2020/09/lsblk-command/</link>
      <pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/09/lsblk-command/</guid>
      <description>linux의 lsblk 명령어를 통해 장치 정보를 확인 할 수 있습니다.
기본 사용법 $&amp;gt; lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT loop1 7:1 0 97M 1 loop /snap/core/9665 loop8 7:8 0 96.6M 1 loop /snap/core/9804 loop6 7:6 0 55.3M 1 loop /snap/core18/1885 loop4 7:4 0 50.4M 1 loop /snap/bpftrace/63 loop2 7:2 0 9.8M 1 loop /snap/helm/265 loop0 7:0 0 55M 1 loop /snap/core18/1880 loop7 7:7 0 26.1M 1 loop /snap/taskbook/23 sda 8:0 0 238.</description>
    </item>
    
    <item>
      <title>lsof command</title>
      <link>https://geeksaga.com/2020/09/lsof-command/</link>
      <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/09/lsof-command/</guid>
      <description>linux의 lsof 명령어는 열려 있는 파일과 해당하는 프로세스 목록을 보여줍니다.
기본 사용법 $&amp;gt; lsof COMMAND PID TID USER FD TYPE DEVICE SIZE/OFF NODE NAME ... chrome 687 geeksaga 15r CHR 1,9 0t0 11 /dev/urandom chrome 687 geeksaga 16r FIFO 0,12 0t0 114907104 pipe chrome 687 geeksaga 17w FIFO 0,12 0t0 114907104 pipe chrome 687 geeksaga 18u unix 0x0000000000000000 0t0 114913656 type=STREAM chrome 687 geeksaga 19u unix 0x0000000000000000 0t0 66804623 type=SEQPACKET .</description>
    </item>
    
    <item>
      <title>fd command</title>
      <link>https://geeksaga.com/2020/09/fd-command/</link>
      <pubDate>Mon, 07 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/09/fd-command/</guid>
      <description>linux의 fd 명령어는 find명령어를 대체할 수 있는 사용자 친화적인 CLI 입니다.
기본 사용법 $&amp;gt; fd test/1.txt ... TLDR $&amp;gt; tldr fd fd An alternative to find. Aims to be faster and easier to use than find. More information: https://github.com/sharkdp/fd. - Find files matching the given pattern in the current directory: fd pattern - Find files that begin with &amp;#34;foo&amp;#34;: fd &amp;#39;^foo&amp;#39; - Find files with a specific extension: fd --extension txt - Find files in a specific directory: fd pattern path/to/dir - Include ignored and hidden files in the search: fd --hidden --no-ignore pattern See also: find Help $&amp;gt; fd --help fd 8.</description>
    </item>
    
    <item>
      <title>find command</title>
      <link>https://geeksaga.com/2020/09/find-command/</link>
      <pubDate>Mon, 07 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/09/find-command/</guid>
      <description>linux의 find 명령어를 통해 파일 또는 디렉토리를 검색할 수 있습니다.
기본 사용법 $&amp;gt; find ./test/1.txt ... 응용 현재 디렉토리 아래 모든 파일 및 하위 디렉토리에서 파일 검색 $&amp;gt; find . -name [FILE] 파일 이름이 특정 문자열로 시작하는 파일 검색 $&amp;gt; find . -name &amp;#34;STRING&amp;#34; 파일 또는 디렉토리만 검색 $&amp;gt; find . -name [FILE] -type f TLDR $&amp;gt; tldr find find Find files or directories under the given directory tree, recursively. - Find files by extension: find root_path -name &amp;#39;*.</description>
    </item>
    
    <item>
      <title>taskset command</title>
      <link>https://geeksaga.com/2020/09/taskset-command/</link>
      <pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/09/taskset-command/</guid>
      <description>linux의 taskset 명령어를 통해 프로세스가 사용할 CPU를 보여주거나 설정할 수 있습니다.
기본 사용법 $&amp;gt; taskset -p 6525 pid 6525&amp;#39;s current affinity mask: ff $&amp;gt; taskset -pc 6525 pid 6525&amp;#39;s current affinity list: 0-7 응용 동일한 코어에서 두 스레드 간에 메세지를 보내는데 걸리는 시간 측정 (이 결과로 컨텍스트 스위칭시 성능을 알 수 있습니다.) $&amp;gt; taskset -c 0 perf bench sched pipe -T # Running &amp;#39;sched/pipe&amp;#39; benchmark: # Executed 1000000 pipe operations between two threads Total time: 3.</description>
    </item>
    
    <item>
      <title>du command</title>
      <link>https://geeksaga.com/2020/08/du-command/</link>
      <pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/du-command/</guid>
      <description>linux의 du 명령어를 통해 디렉토리 별로 디스크 사용량을 확인 할 수 있습니다.
기본 사용법 $&amp;gt; du /usr/bin 557780	/usr/bin 출력되는 값은 --block-size 또는 DU_BLCOK_SIZE, BLOCK_SIZE, BLOCKSIZE 환경 변수에서 사용 가능한 첫 번째 SIZE 단위 입니다. 그렇지 않으면 단위는 기본적으로 1024 바이트 (또는 POSIXLY_CORRECT가 설정된 경우 512) 입니다.
TLDR $&amp;gt; tldr du du Disk usage: estimate and summarize file and directory space usage. - List the sizes of a directory and any subdirectories, in the given unit (B/KB/MB): du -b|k|m path/to/directory - List the sizes of a directory and any subdirectories, in human-readable form (i.</description>
    </item>
    
    <item>
      <title>df command</title>
      <link>https://geeksaga.com/2020/08/df-command/</link>
      <pubDate>Tue, 18 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/df-command/</guid>
      <description>linux의 df 명령어를 통해 현재 디스크의 전체 사용량을 확인 할 수 있습니다.
기본 사용법 $&amp;gt; df Filesystem 1K-blocks Used Available Use% Mounted on udev 8123612 0 8123612 0% /dev tmpfs 1630992 17960 1613032 2% /run /dev/mapper/mint--vg-root 229063924 159664024 57741048 74% / tmpfs 8154948 554936 7600012 7% /dev/shm tmpfs 5120 4 5116 1% /run/lock tmpfs 8154948 0 8154948 0% /sys/fs/cgroup /dev/sda1 482922 279826 178162 62% /boot cgmfs 100 0 100 0% /run/cgmanager/fs tmpfs 1630992 520 1630472 1% /run/user/1000 출력된 정보는 다음과 같습니다.</description>
    </item>
    
    <item>
      <title>netstat command</title>
      <link>https://geeksaga.com/2020/08/netstat-command/</link>
      <pubDate>Tue, 18 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/netstat-command/</guid>
      <description>linux의 netstat 명령어를 통해 현재 연결된 네트워크 상태, 라우팅 테이블, 인터페이스 상태, IP Masquerade, 멀티캐스트 멤버쉽 등을 확인 할 수 있습니다.
기본 사용법 $&amp;gt; netstat Active Internet connections (w/o servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 192.168.0.50:38608 nrt20s21-in-f10.1:https ESTABLISHED ... Active UNIX domain sockets (w/o servers) Proto RefCnt Flags Type State I-Node Path unix 2 [ ] DGRAM 34946 /run/user/1000/systemd/notify unix 3 [ ] DGRAM 19785 /run/systemd/notify unix 3 [ ] SEQPACKET CONNECTED 238454 @0002d .</description>
    </item>
    
    <item>
      <title>iostat command</title>
      <link>https://geeksaga.com/2020/08/iostat-command/</link>
      <pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/iostat-command/</guid>
      <description>linux의 iostat 명령어를 통해 평균 CPU 부하 및 디스크 I/O 정보를 확인 할 수 있습니다.
기본 사용법 $&amp;gt; iostat Linux 4.15.0-112-generic (geeksaga) 08/14/2020 _x86_64_	(8 CPU) avg-cpu: %user %nice %system %iowait %steal %idle 6.92 0.00 2.11 0.03 0.00 90.94 Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtn sda 6.00 21.54 202.41 15318970 143972371 dm-0 9.19 21.52 229.52 15308169 163262564 dm-1 0.01 0.00 0.04 2456 30392 출력된 정보는 다음과 같습니다.
Device : 디바이스 목록 tps : 초당 전송 요청 건수 KB_read/s : 디바이스에서 초당 읽은 데이터 블락 수 KB_wrtn/s : 디바이스에 초당 쓴 데이터 블락 수 KB_read : 디바이스에서 읽은 총 블락 수 KB_wrtn : 디바이스에 쓴 총 블락 수 옵션 사용법 -x : 확장 통계를 보여줍니다.</description>
    </item>
    
    <item>
      <title>vmstat command</title>
      <link>https://geeksaga.com/2020/08/vmstat-command/</link>
      <pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/vmstat-command/</guid>
      <description>linux의 vmstat 명령어를 통해 프로세스, 메모리, 페이징, I/O, CPU 관련 정보를 확인 할 수 있습니다.
기본 사용법 $&amp;gt; vmstat procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 31232 935260 2147660 4477324 0 0 3 13 4 3 7 2 91 0 0 출력된 정보는 다음과 같습니다.
procs r : 실행중이거나 대기중인 기다리고 있는 프로세스의 수 b : 인터럽트가 불가능한 상태로 sleep 상태에 있는 프로세스의 수 memory swpd : 가상메모리로 사용되는 크기 free : 남아있는 메모리 크기 buff : 버퍼에 사용되고 있는 메모리 크기 cache : 캐시에 사용되고 있는 메로리 크기 swap si : swap in 된 크기(초당 디스크에서 읽어 메모리 호출된 크기) so : swap out 된 크기(*초당 메모리에서 디스크로 보내지는 크기) io bi : 블락 디바이스에서 받은 블락 수 bo : 블락 디바이스로 보낸 블락 수 system in : 초당 발생하는 인터럽트 수 cs : 초당 발생하는 컨텍스트 스위치 수 cpu us : nice 시간을 포함하는 사용자 시간 비율 sy : 시스템이 사용한 시간 비율 id : 대기시간 비율(IO-wait 시간 포함) wa : 입출력 대기시간 비율(idle 시간 포함) st : VM 사용시 가상머신이 실제 CPU 를 기다리는 시간 비율 디바이스 종류는 블락 디바이스(Block Device)와 캐릭터 디바이스(Character Device)가 있습니다.</description>
    </item>
    
    <item>
      <title>free command</title>
      <link>https://geeksaga.com/2020/08/free-command/</link>
      <pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/free-command/</guid>
      <description>linux의 free 명령어를 통해 메모리에 대한 정보를 확인 할 수 있습니다.
기본 사용법 $&amp;gt; free total used free shared buff/cache available Mem: 16309896 8769820 983176 423232 6556900 6621048 Swap: 16658428 768 16657660 출력된 정보는 다음과 같습니다.
Mem : 실제 메모리 Swap : 가상 메모리 total : 전체 메모리 크기(MemTotal and SwapTotal /proc/meminfo) used : 사용중인 메모리 크기(used = total - free -buffers - cache) free : 사용되지 않은 메모리(MemFree and SwapFree /proc/meminfo) shared : buff/cache : 버퍼와 캐시의 합 buffers : 커널이 사용중인 버퍼 크기(Buffers /proc/meminfo) cache : 페이지 캐시와 Slab(Cached and Slab /proc/meminfo) available : 사용가능한 메모리 크기 help free $&amp;gt; free --help Usage: free [options] Options: -b, --bytes show output in bytes -k, --kilo show output in kilobytes -m, --mega show output in megabytes -g, --giga show output in gigabytes --tera show output in terabytes -h, --human show human-readable output --si use powers of 1000 not 1024 -l, --lohi show detailed low and high memory statistics -t, --total show total for RAM + swap -s N, --seconds N repeat printing every N seconds -c N, --count N repeat printing N times, then exit -w, --wide wide output --help display this help and exit -V, --version output version information and exit For more details see free(1).</description>
    </item>
    
    <item>
      <title>ifconfig</title>
      <link>https://geeksaga.com/2020/08/ifconfig/</link>
      <pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/ifconfig/</guid>
      <description>linux의 ifconfig는 시스템에 설정된 네트워크 인터페이스의 상태를 확인 할 수 있는 명령어 입니다.
$&amp;gt; ifconfig docker0 Link encap:Ethernet HWaddr 02:42:ed:b0:91:f2 inet addr:172.17.0.1 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) enp3s0 Link encap:Ethernet HWaddr 74:d4:35:1e:a9:87 inet addr:192.168.0.50 Bcast:192.168.0.255 Mask:255.255.255.0 inet6 addr: fe80::3be5:4edf:81f5:2037/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:11149676 errors:0 dropped:0 overruns:0 frame:0 TX packets:9835684 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:3583344722 (3.</description>
    </item>
    
    <item>
      <title>bash &amp; zsh Shortcuts</title>
      <link>https://geeksaga.com/2020/08/bash-zsh-shortcuts/</link>
      <pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/bash-zsh-shortcuts/</guid>
      <description>자주 사용하는 단축키 목록 CTRL + A : 라인 시작으로 이동 CTRL + E : 라인 끝으로 이동 CTRL + Left Arrow : 한단어 왼쪽으로 이동 ALT + B CTRL + Right Arrow : 한단어 오른쪽으로 이동 ALT + F CTRL + U (bash) : 라인 시작 부터 현재 커서까지 삭제 CTRL + U (zsh) : 라인 삭제 CTRL + K : 현재 커서 위치 부터 라인 끝까지 삭제 CTRL + W : 커서 앞 단어 삭제 CTRL + R : 히스토리 검색 CTRL + G : 히스토리 검색 빠져나오기 CTRL + + : 콘솔 폰트 키우기 CTRL + - : 콘솔 폰트 줄이기 zsh 사용시 bindkey 명령어를 이용하여 단축키 목록을 볼 수 있다.</description>
    </item>
    
    <item>
      <title>xargs command</title>
      <link>https://geeksaga.com/2020/08/xargs-command/</link>
      <pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/xargs-command/</guid>
      <description>linux의 xargs 명령어는 출력된 결과를 인자값으로 이용하여 다른 명령어를 활용할 수 있게 만들어 주는 명령어입니다.
$&amp;gt; find /etc -name &amp;#34;*.conf&amp;#34; | xargs ls -l 위 명령어는 /etc 경로 밑에 있는 .conf로 끝나는 모든 파일을 찾은 다음 파이프(|)를 통해 xargs에 인자값으로 넘겨 주고 ls -l 명령어를 통해서 출력하도록 하는 조합입니다.
응용으로 다음 처럼 특정 파일들만 찾은 후에 파일을 압축하는데 사용할 수도 있습니다.
$&amp;gt; find ~/Downloads -name &amp;#34;*.jpg&amp;#34; -type f | xargs tar -cvzf jpg-images.</description>
    </item>
    
    <item>
      <title>awk &amp; gawk command</title>
      <link>https://geeksaga.com/2020/08/awk-gawk-command/</link>
      <pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/awk-gawk-command/</guid>
      <description>linux의 awk 명령어는 GNU 버전의 gawk로 심볼릭 링크되어 있습니다.
awk는 최초 기능을 만든 Aho + Weinberger + Kernighan(A:Alfred V. Aho, W:Peter J. Weinberger, K:Brian W. Kernighan) 3명의 이니셜을 조합하여 만든 이름 입니다.
표준 입력에 의한 데이터를 조작하거나 데이터화하는 용도로 사용하는 명령어 입니다.
기본 사용법 표준 입력 또는 파일을 읽어들여 &amp;lsquo;&amp;lsquo;로 둘러싸인 패턴을 읽어 들여 공백 또는 탭을 기준으로 파싱해서 $1 부터 시작하는 변수를 만들어 줍니다.
참고로 $0은 입력된 모든 값을 가지고 있습니다.</description>
    </item>
    
    <item>
      <title>grep command</title>
      <link>https://geeksaga.com/2020/08/grep-command/</link>
      <pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/grep-command/</guid>
      <description>linux의 grep은 파일 또는 표준 입력(Standard input)에 대해서 특정 패턴을 통해 검색 해주는 명령어 입니다.
패턴에 대해서는 기본값으로 기본 정규 표현식(basic regular expression - BRE)을 지원 합니다.
기본적인 사용 법은 다음과 같습니다.
$&amp;gt; grep Usage: grep [OPTION]... PATTERN [FILE]... Try &amp;#39;grep --help&amp;#39; for more information. $&amp;gt; grep Error /var/log/syslog Aug 3 10:20:25 geeksaga org.a11y.Bus[4449]: ** (process:4467): WARNING **: Failed to register client: GDBus.Error:org.freedesktop.DBus.Error.ServiceUnknown: The name org.gnome.SessionManager was not provided by any .</description>
    </item>
    
    <item>
      <title>sed command</title>
      <link>https://geeksaga.com/2020/08/sed-command/</link>
      <pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/sed-command/</guid>
      <description>linux의 sed(Stream editor) 명령은 패턴을 통해 텍스트를 변환하여 출력해주는 스트림 편집기입니다.
help sed $&amp;gt; sed Usage: sed [OPTION]... {script-only-if-no-other-script} [input-file]... -n, --quiet, --silent suppress automatic printing of pattern space -e script, --expression=script add the script to the commands to be executed -f script-file, --file=script-file add the contents of script-file to the commands to be executed --follow-symlinks follow symlinks when processing in place -i[SUFFIX], --in-place[=SUFFIX] edit files in place (makes backup if SUFFIX supplied) -l N, --line-length=N specify the desired line-wrap length for the `l&amp;#39; command --posix disable all GNU extensions.</description>
    </item>
    
    <item>
      <title>watch command</title>
      <link>https://geeksaga.com/2020/08/watch-command/</link>
      <pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/08/watch-command/</guid>
      <description>linux의 watch 명령어는 특정 명령어를 반복하여 실행할 때 유용한 명령어 입니다.
$&amp;gt; watch -n 3 df 간단한 쉘스크립트를 이용해도 비슷한 효과를 볼 수 있습니다.
$&amp;gt; while true \n do \n df \n sleep 3 \n done help watch $&amp;gt; watch --help Usage: watch [options] command Options: -b, --beep beep if command has a non-zero exit -c, --color interpret ANSI color and style sequences -d, --differences[=&amp;lt;permanent&amp;gt;] highlight changes between updates -e, --errexit exit if command has a non-zero exit -g, --chgexit exit when output from command changes -n, --interval &amp;lt;secs&amp;gt; seconds to wait between updates -p, --precise attempt run command in precise intervals -t, --no-title turn off header -x, --exec pass command to exec instead of &amp;#34;sh -c&amp;#34; -h, --help display this help and exit -v, --version output version information and exit For more details see watch(1 Usage: uptime [options] Options: -p, --pretty show uptime in pretty format -h, --help display this help and exit -s, --since system up since -V, --version output version information and exit For more details see uptime(1).</description>
    </item>
    
    <item>
      <title>ulimit command</title>
      <link>https://geeksaga.com/2020/07/ulimit-command/</link>
      <pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/07/ulimit-command/</guid>
      <description>linux의 ulimit 명령은 프로세스의 자원 한도를 설정하는 명령어 입니다.
보여 주는 형식은 Linux 또는 커널 버전 마다 다르지만 보여주는 내용은 비슷 합니다.
제한 설정은 soft 또는 hard로 나누어 집니다.
soft : 프로그램을 새로 시작하면 기본으로 적용되는 제한. hard : soft에서 설정할 수 있는 최대 제한.
CentOS or Ubuntu 20.x LTS $&amp;gt; ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 3560 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 3560 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited Mint or Ubuntu 18.</description>
    </item>
    
    <item>
      <title>top command</title>
      <link>https://geeksaga.com/2020/07/top-command/</link>
      <pubDate>Thu, 30 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/07/top-command/</guid>
      <description>linux의 top 명령을 통해 실시간 수행중인 프로세스들에 대한 정보를 볼 수 있습니다.
top 자체 명령어가 많기 때문에 Man page를 이용하면 좋습니다.
$&amp;gt; top top - 15:01:58 up 3 days, 51 min, 1 user, load average: 0.32, 0.21, 0.15 Tasks: 370 total, 1 running, 298 sleeping, 0 stopped, 0 zombie %Cpu(s): 1.6 us, 1.0 sy, 0.0 ni, 97.4 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 16309896 total, 5783464 free, 5049060 used, 5477372 buff/cache KiB Swap: 16658428 total, 16234492 free, 423936 used.</description>
    </item>
    
    <item>
      <title>dmidecode command</title>
      <link>https://geeksaga.com/2020/07/dmidecode-command/</link>
      <pubDate>Wed, 29 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/07/dmidecode-command/</guid>
      <description>linux의 dmidecode은 DMI(alternatively known as SMBIOS) 테이블 내용을 사람이 읽을 수 형태로 보여주는 명령어 입니다.
이 명령어를 사용하려면 root 권한이 필요 합니다.
한번에 많은 정보를 보여주기 때문에 more를 이용하여 화면 단위로 내용을 보면 유용합니다.
$&amp;gt; sudo dmidecode | more # dmidecode 3.0 Getting SMBIOS data from sysfs. SMBIOS 2.7 present. 76 structures occupying 3048 bytes. Table at 0x000EB530. Handle 0x0000, DMI type 0, 24 bytes BIOS Information Vendor: American Megatrends Inc.</description>
    </item>
    
    <item>
      <title>uname command</title>
      <link>https://geeksaga.com/2020/07/uname-command/</link>
      <pubDate>Wed, 29 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/07/uname-command/</guid>
      <description>linux의 uname 명령를 사용하면 현재 실행중인 머신과 OS(Operating System) 등의 시스템 정보를 확인 할 수 있습니다.
$&amp;gt;uname Linux -a 옵션을 통해 가능한 모든 시스템 정보(hardware, software, nodename)를 보여 줍니다.
$&amp;gt;uname -a Linux geeksaga 4.15.0-107-generic #108~16.04.1-Ubuntu SMP Fri Jun 12 02:57:13 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 위에 출력된 내용은 부분별로 다음 정보를 의미 합니다.
Linux : 커널 이름 geeksaga : 노드 이름 4.15.0-107-generic : 커널 릴리즈 정보 #108~16.04.1-Ubuntu SMP Fri Jun 12 02:57:13 UTC 2020 : 커널 버전 정보 x86_64 : 하드웨어 이름 x86_64 : 프로세서 타입 x86_64 : 하드웨어 플랫폼 GNU/Linux : 운영체제 uname &amp;ndash;help $&amp;gt;uname --help Usage: uname [OPTION].</description>
    </item>
    
    <item>
      <title>uptime command</title>
      <link>https://geeksaga.com/2020/07/uptime-command/</link>
      <pubDate>Wed, 29 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/07/uptime-command/</guid>
      <description>linux의 uptime 명령을 통해 시스템의 운영시간 및 평균 시스템 부하를 확인 할 수 있습니다.
$&amp;gt;uptime 14:05:49 up 1 day, 23:55, 1 user, load average: 1.43, 0.94, 0.82 위에 출력된 내용은 부분별로 다음 정보를 의미 합니다.
14:05:49 : 현재시간 up 1 day, 23:55 : 시스템 시작후 운영된 시간 1 user : 시스템에 현재 로그인된 사용자 수 로그인된 사용자 정보는 /var/run/utmp 파일을 참조한다. w, who 명령어를 통해서 상세 정보를 확인 할 수 있다.</description>
    </item>
    
    <item>
      <title>shell에 설정된 alias를 우회하는 방법들</title>
      <link>https://geeksaga.com/2020/07/shell%EC%97%90-%EC%84%A4%EC%A0%95%EB%90%9C-alias%EB%A5%BC-%EC%9A%B0%ED%9A%8C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EB%93%A4/</link>
      <pubDate>Tue, 28 Jul 2020 14:12:45 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/07/shell%EC%97%90-%EC%84%A4%EC%A0%95%EB%90%9C-alias%EB%A5%BC-%EC%9A%B0%ED%9A%8C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EB%93%A4/</guid>
      <description>Shell에 설정된 alias 대신 원래 명령어를 실행하는 여러가지 방법들. $&amp;gt; alias ls=ext ls alias가 설정되어 있을 경우 ls 명령어를 입력하면 ext 명령어가 실행된다.
이를 alias 설정 이전 ls 명령어로 실행할 수 있는 방법은 다음과 같다.
절대 경로를 이용하는 방법. $&amp;gt; whereis ls ls: /bin/ls /usr/share/man/man1/ls.1.gz $&amp;gt; /bin/ls command 명령을 이용하는 방법. $&amp;gt; command ls &amp;ldquo;(double quotation)을 이용하는 방법. $&amp;gt; &amp;#34;ls&amp;#34; &amp;lsquo;(single quotation)을 이용하는 방법. $&amp;gt; &amp;#39;ls&amp;#39; \(backslash)를 이용하는 방법. $&amp;gt; \ls </description>
    </item>
    
    <item>
      <title>whereis command</title>
      <link>https://geeksaga.com/2020/07/whereis-command/</link>
      <pubDate>Tue, 28 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/07/whereis-command/</guid>
      <description>linux의 whereis는 입력한 명령어(command)의 실행파일, 소스, Man 페이지 위치를 찾는 명령어입니다.
whereis &amp;ndash;help $&amp;gt; whereis --help Usage: whereis [options] [-BMS &amp;lt;dir&amp;gt;... -f] &amp;lt;name&amp;gt; Locate the binary, source, and manual-page files for a command. Options: -b search only for binaries -B &amp;lt;dirs&amp;gt; define binaries lookup path -m search only for manuals and infos -M &amp;lt;dirs&amp;gt; define man and info lookup path -s search only for sources -S &amp;lt;dirs&amp;gt; define sources lookup path -f terminate &amp;lt;dirs&amp;gt; argument list -u search for unusual entries -l output effective lookup paths For more details see whereis(1).</description>
    </item>
    
    <item>
      <title>which command</title>
      <link>https://geeksaga.com/2020/07/which-command/</link>
      <pubDate>Tue, 28 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/07/which-command/</guid>
      <description>linux의 which는 입력한 명령어를 $PATH에 설정된 범위에서 검색하여 찾아주는 명령어입니다.
옵션 없이 사용할 경우 먼저 매치되는 명령어를 보여 줍니다.
$&amp;gt; which ls ls: aliased to exa -a 옵션을 통해 매치는 명령어가 여러개 있을 경우 모두 보여 줍니다.
$&amp;gt; which -a ls /ls: aliased to exa /bin/ls </description>
    </item>
    
    <item>
      <title>tee</title>
      <link>https://geeksaga.com/2020/07/tee/</link>
      <pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/07/tee/</guid>
      <description>linux 의 tee 명령어는 표준 입력을 받아 표준 출력(Console)과 파일을 만들어주는 명령어입니다.
$&amp;gt; tee --help Usage: tee [OPTION]... [FILE]... Copy standard input to each FILE, and also to standard output. -a, --append append to the given FILEs, do not overwrite -i, --ignore-interrupts ignore interrupt signals -p diagnose errors writing to non pipes --output-error[=MODE] set behavior on write error. See MODE below --help display this help and exit --version output version information and exit MODE determines behavior with write errors on the outputs: &amp;#39;warn&amp;#39; diagnose errors writing to any output &amp;#39;warn-nopipe&amp;#39; diagnose errors writing to any output not a pipe &amp;#39;exit&amp;#39; exit on error writing to any output &amp;#39;exit-nopipe&amp;#39; exit on error writing to any output not a pipe The default MODE for the -p option is &amp;#39;warn-nopipe&amp;#39;.</description>
    </item>
    
    <item>
      <title>pgrep</title>
      <link>https://geeksaga.com/2020/04/pgrep/</link>
      <pubDate>Mon, 27 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/04/pgrep/</guid>
      <description>linux 의 pgrep 명령어는 확장 정규 표현식 패턴으로 모든 프로세스의 이름을 검색할 수 있으며 기본적으로 프로세스 ID를 반환한다.
기본 사용법은 다음과 같다.
λ pgrep zsh 1353 1541 Usage: pgrep [options] &amp;lt;pattern&amp;gt; Options: -d, --delimiter &amp;lt;string&amp;gt; specify output delimiter -l, --list-name list PID and process name -a, --list-full list PID and full command line -v, --inverse negates the matching -w, --lightweight list all TID -c, --count count of matching processes -f, --full use full process name to match -g, --pgroup &amp;lt;PGID,.</description>
    </item>
    
    <item>
      <title>Shell Script date 커맨드를 이용한 날짜를 변수로 변환하는 방법</title>
      <link>https://geeksaga.com/2020/03/shell-script-date-%EC%BB%A4%EB%A7%A8%EB%93%9C%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%82%A0%EC%A7%9C%EB%A5%BC-%EB%B3%80%EC%88%98%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</link>
      <pubDate>Wed, 18 Mar 2020 10:39:28 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/03/shell-script-date-%EC%BB%A4%EB%A7%A8%EB%93%9C%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%82%A0%EC%A7%9C%EB%A5%BC-%EB%B3%80%EC%88%98%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</guid>
      <description>date 커맨드를 이용한 날짜를 변수로 변환하는 방법 $&amp;gt; today=`date +%Y%m%d` $&amp;gt; echo $today 20200318 $&amp;gt; yesterday=`date +%Y%m%d -d &amp;#39;-1days&amp;#39;` $&amp;gt; echo $yesterday 20200317 참고 링크 man-pages </description>
    </item>
    
    <item>
      <title>note</title>
      <link>https://geeksaga.com/2020/03/note/</link>
      <pubDate>Tue, 17 Mar 2020 14:51:26 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/03/note/</guid>
      <description>/etc/skel/ 새로운 유저가 생성되면 자동으로 /etc/skel 디렉토리내에 있는 파일들을 새로운 사용자의 홈디렉토리로 복사하는 과정을 거치게 된다.
old kernels remove Debian 계열 리눅스.
현재 적용중인 커널 버전 확인.
$&amp;gt; uname -r 4.15.0-88-generic 설치되어 있는 커널 확인.
$&amp;gt; dpkg --list | grep linux-image $&amp;gt; dpkg --list | grep linux-headers ii linux-image-4.13.0-45-generic 4.13.0-45.50~16.04.1 amd64 Linux kernel image for version 4.13.0 on 64 bit x86 SMP ii linux-image-4.15.0-76-generic 4.15.0-76.86~16.04.1 amd64 Signed kernel image generic ii linux-image-4.</description>
    </item>
    
    <item>
      <title>dig</title>
      <link>https://geeksaga.com/2020/03/dig/</link>
      <pubDate>Wed, 11 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2020/03/dig/</guid>
      <description>linux 의 dig 명령어는
기본 사용법은 다음과 같다.
$&amp;gt;dig www.geeksaga.com ; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.10.3-P4-Ubuntu &amp;lt;&amp;lt;&amp;gt;&amp;gt; www.geeksaga.com ;; global options: +cmd ;; Got answer: ;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 29343 ;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1452 ;; QUESTION SECTION: ;www.geeksaga.com.	IN	A ;; ANSWER SECTION: www.geeksaga.com.	10331	IN	A	185.199.109.153 www.geeksaga.com.	10331	IN	A	185.</description>
    </item>
    
    <item>
      <title>less</title>
      <link>https://geeksaga.com/2018/06/less/</link>
      <pubDate>Fri, 08 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://geeksaga.com/2018/06/less/</guid>
      <description>linux 의 less 명령어는 파일 내용을 확인하는 명령어들 중에 하나로 파일을 읽어 화면에 출력하는 명령어이다. 비슷한 명령어로 cat, more가 있다. more는 파일 내용을 확인 할 떄 위에서 아래 방향으로만 출력되어 지나간 내용을 다시 볼 수 없지만 less는 한 번에 보여지는 만큼만 읽어서 출력하기 때문에 크기가 큰 파일을 볼 때 유용하게 사용할 수 있다.
기본 사용법은 다음과 같다.
$&amp;gt;less [filename] 기본동작은 엔터키를 입력하면 한줄씩 출력되고 스페이스바를 입력하면 한 화면씩 출력된다.
옵션 텍스트 모드 단축키 q : 프로그램 종료 엔터 : 1라인 아래로 이동 방향키 업 : 위로 1라인 이동 방향키 다운 : 아래로 1라인 이동 b or page up : 위로 1페이지 이동 space bar or page down : 아래로 1페이지 이동 G : 텍스트 파일의 제일 마지막으로 이동 1G or g : 텍스트 파일의 맨 처음으로 이동 /문자열 : 아래 방향으로 진행하며 입력된 문자열 찾기 n : 이전 검색어의 다음 찾기 z : 아래로 한 화면 이동 w : 위로 한 화면 이동 d : 아래로 화면의 절반 이동 u : 위로 화면의 절반 이동 h : 도움말 보기 +[linenumber] : 지정된 라인부터 내용을 출력 +G : 텍스트 파일의 제일 마지막 내용을 출력 </description>
    </item>
    
  </channel>
</rss>
